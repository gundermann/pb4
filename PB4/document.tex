\documentclass[a4paper]{scrartcl}
\usepackage[ngerman]{babel}
\usepackage[ansinew]{inputenc}
\usepackage{lmodern}
\usepackage[margin=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{listings} 
\usepackage{multirow}
\usepackage{cite}
\lstset{language=java} 
\lstset{basicstyle=\scriptsize}
\lstset{numbers=left, numberstyle=\tiny, numbersep=2pt} 

\graphicspath{{Bilder/}}

\linespread{1.5}

\title{Praxisbericht: Prototypische Implementierung eines JavaFX/Web-Channels zur Integration ins MulitChannel-Framework der deg}
\author{Niels Gundermann}

\begin{document}
\bibliographystyle{geralpha}
\large
\maketitle
\pagebreak
\tableofcontents
\pagebreak

\listoffigures
\pagebreak

\section{Einleitung}
Ausgehend von dem Fazit des Praxisberichtes \grqq Prototypische Implementierung
eines JavaFX-Channels zur Integration ins MulitChannel-Framework der deg\grqq
  ist Swing ein veraltetes Framework, dass durch ein neues Framework ersetzt
werden sollte. Dies bezieht sich nur auf den Bereich der Desktopanwedungen bzw.
dem Desktoprendering.\\
PROFIL-C/S wird nicht nur als Desktopanwendung verwendet, sondern auch im
Web-Bereich. Das bedeutet, dass bei einer Neuausrichtung der Technologien für
die unterschiedlichen Channels auch der Einsatz in Browsern bedacht werden
muss.\\
Derzeit setzt die deg dafür das Wings-Framework ein.
Dieses Framework ist allerdings genauso wie Swing veraltet und wird nicht mehr
gewartet. Support für dieses Framework wird demnach vergebens gesucht.\\
Aufgrund dessen wird in dieser Arbeit nach einer Alternative für den
WingS-Channel der deg und PROFIL C/S gesucht.\\ 
Da sich der vorherige Praxisbericht mit JavaFX beschäftigte, 
wird zu Beginn auf Möglichkeiten eingegangen, 
den implementierten Prototypen des JavaFX-Channel direkt im Browser zu
rendern.\\
Im Anschluss wird das Vaadin-Framework, als Beispiel für ein mögliches
Web-Framework, genauer beleuchtet. Dazu gehört auch ein Vergleich zum
bestehenden Wings-Framework.\\ 
Zum Ende wird ein Prototyp einer PROFIL-C/S
GUI für den Einsatz im Web vorgestellt und auf Probleme in Bezug auf das
Multichannel-Framework der deg eingegangen.


\section{JavaFX alleine als Multichannel?}
Ausgehend davon, dass ein Multichannel die Möglichkeit bieten soll, die UIs nur
einmal implementieren zu müssen und im Anschluss auf mehreren Oberflächen
eingesetzt zu werden. Von einer zumindest ähnlichen Darstellung auf den
unterschiedlichen Oberflächen wird dabei ebenfalls ausgegangen.\\
JavaFX bietet die Möglichkeit sowohl auf dem Desktop, als auch in
einem Browser gerendert zu werden\cite{JavaFXDoc:Online}
Hierbei handelt es sich um ein Java-Applet. Das Deployment solcher Applets ist
jedoch vergleichsweise sehr zeitaufwändig. Der Grund dafür ist vor allem, dass
die JVM zuvor initialisiert werden muss.\cite{} Dem entgegenzuhalten ist, dass man
somit gezwungen ist, die Clients möglichst klein\footnote{bedeutet in diesem Kontext, dass sich die Funktionen, die
im Client implementiert sind, weites gehend nur auf die GUI und entsprechenden
Listener, die zum Steuern der Anwendung benötigt werden, beschränkt. Die Logik
und Funktionen, die über die Bedienung der GUI hinaus gehen, sollten sich nach
Möglichkeit auf dem Server befinden - unter der Voraussetzung, dass dort
genügend Speicher vorhanden ist, um die Anfragen der Clients in angemessener
Zeit beantworten zu können} zu halten. Allerdings sind Größe und Funktionalität
in einem bestehenden System schwer beeinflussbar. Weiterhin ist es auch
nicht das Ziel die Clients umzustricken.\\
Der große Vorteil dieser Technologie ist, dass für die GUI für beide
Oberflächen (Browser und Desktop) nur einmal entwickelt werden muss. Die Zusammenarbeit mit
Applikationsservern, was für Profil C/S unbedingt von Nöten ist, ist unter
Umständen möglich. Dafür müssen die Applets lediglich signiert werden. Das bedeutet, dass das Applet mit einem digitalen Zertifikat
unterzeichnet werden muss und somit gewährleistet wird, dass es sich dabei um
ein von der deg enntwickeltes Programm handelt. Somit kann der Nutzer eventuelle
Fehler und aufkommende Sicherheitslücken genau zuordnen.\cite{DeployTutJar}\\
Notwendig für die Nutzung von Java-Applets ist eine entsprechende html-Datei, in
der eine jnlp-Datei mittels Java-Script eingebunden wird. Weiterhin muss der Anwender mit einem
Browser arbeiten, in dem das Java-Plugin integriert oder installiert werden
kann. Zusätzlich ist die Aktivierung von Java-Script und damit das
Umgehen von Sicherheitsrichtlinien von Nöten.\cite{DeployTutApp}\\
Abbildung 1 zeigt eine Tabelle in der Vor- und Nachteile dieser Technologie
aufgelistet sind.\\



\section{Web-Frameworks}
Web-Frameworks bieten die Möglichkeit bestimmte Inhalte mit Hilfe von
Technologien zu visualisieren, die vor allem in Internet-Browsern benutzt
werden. In der Regel ist das Ausführen von Programmen, die mit Web-Frameworks
implementiert wurden, auf dem Desktop nicht möglich. Wir ein solches Framework
zum Beispiel neben JavaFX eingesetzt, ist es Möglich die Logik zentral zu
implementieren und die Visualisierung zu separieren.\\
Der Nachteil, in Bezug auf die Implemetierung, ist, dass für unterschiedliche
Frameworks, die unterschiedliche Technologien nutzen, auch doppelter Aufwand
aufkommt. Um diese doppelten Aufwad möglichstklein zu halten, wurde dafür bei
der deg ein Multichannel implementiert.
\subsection{Multichannel}
Bezogen auf dieses Problem führt der Multichannel unterschiedlichen
Frameworks für die Visualisierung auf dem Desktop und im Browser
zusammen. Die Userinterfaces werden dann in der Syntax und Semantik des
Multichannel-Framework geschrieben. Die Entwickler müssen somit nicht die unterschiedlichen GUI-Frameworks kennen, sondern nur das
Multichannel-Framework. Je nachdem, auf welcher Plattform das Programm
ausgeführt wird, wird die GUI vom Multichannel über das entsprechende Framework
erstellt.\\
Um einen Multichannel implmentieren zu können, bedarf es einer gemeinsamen
Basis, der unterschiedlichen Frameworks. Die von den Frameworks genutzten
Technologien sind hierbei in erster Linie uninteressant. Das Ziel ist ein
allgemeines Framework zu schreiben, sodass nur noch unterschieden werden muss,
auf welcher Visualisierungsplattform man sich befindet.\\
Ausgegangen wird davon, dass als GUI-Framework für den Desktop JavaFX oder - wie
aktuell - Swing genutzt wird. Somit liegt es nahe ein Framework zu
betrachten das auf Java basiert, um die JVM als gemeinsame Basis nutzten zu
können. Aus diesen Grund wird im Folgenden das Vaadin-Framework vorgestellt.
\subsection{Vaadin}
Das Vaadin-Framework ist ein Open-Source Framework, das es erlaubt
Userinterfaces für Weboberflächen zu implementieren. Dies kann wie bei JavaFX
auf zwei Wegen geschehen. Zum einen durch Java-Code und zum Anderen durch einen Editor. 
Im weiteren Verlauf wird auf die erste Möglichkeit Bezug genommen.\\
Entwickelt wird Vaadin seit 2002. Damals zunächst als Adapter für ein anderes
Web-Framework. Ab 2006 wurde es als eigenes Produkt
entwickelt\footnote{text}.\\
Es enthält zum Einen einen großen Pool an UI-Komponenten, die dem Nutzer für
den Aufbau einer Web-GUI zur Verfügung stehen. Genauso wie bei andere
GUI-Frameworks, die auf Java basieren, ist es möglich neue und eigene
GUI-Komponenten zu entwickeln. Aus diesem Grund gibe es viele AddOns für
das Vaadin-Framework, die noch nicht in das Standardframework
integriert wurden.\\
Der Service bzw. die Unterstützung ist gegeben. Durch verständliche Tutorials,
der guten Dokumentation sowie entsprechenden Plugins für unterschiedliche
Entwicklungsumgebungen, findet man leicht einen Zugang zu dem Framework und kann
es ohne große Konfiguration einsetzen. Auch wenn in der offiziellen
Dokumentation \footnote{Book of Vaadin (siehe [Vaa13])} lediglich die
Standardkomponenten erklärt sind, gibt es zu jedem AddOn eine kurze Einweisung, sowie Beispiele und
Erklärungen. Auch die Community macht einen sehr aktiven Eindruck
\footnote{https://vaadin.com/forum}. Des weiteren stellen die Vaadin-Entwickler
ihr Know-How als externe Berater zur Verfügung.\\
Implementieren lassen sich die GUI-Komponenten nicht nur mittels Java-Code. Da
Vaadin auf der Client-Seite auf das Google-Web-Toolkit (GWT) aufbaut, 
können die UIs auch mittels anderer Sprachen, die zu der JVM kompatibel
sind\footnote{Bspw. Scala, Ruby, Groovy, Clojure, Python}, erstellt werden.
Weiterhin kann Vaadin auf allen Servern bereitgestellt werden, die einen 
Servlet- oder Portlet-Container enthalten. Beispiele dafür sind
Tomcat, Glasfish oder der in der deg eingesetzte JBoss.\\
Die Entwicklung findet auf dem Server statt. Für die Kommunikation zwischen
Server und Client wird AJAX verwendet\cite[S. 23ff.]{Vaadin}.
Von daher sind zusätzliche Plugins für Java-Anwendungen nicht nötig und somit
besteht auch das durch Plugins enstehende Sicherheitsrisiko nicht mehr.

\subsection{Anforderung an die Profil C/S - GUI} 
Sollte es zu einer Implementierung eines neuen Multichannel-Frameworks kommen,
müssen Techologien und Framework eingesetzt werden, die den Anforderung von
Profil C/S gerecht werden. Im Folgenden wird untersucht ob es möglich ist mit
dem Vaadin-Framework eine allgemeine GUI, wie sie in Profil C/S zur Anwendung
kommt, zu implemetieren. Dabei werde ich mich an der mit JavaFX-GUI, die aus dem orangegangen Praxisbericht - \grqq Prototypische Implementierung eines
JavaFX-Channels zur Integration ins MulitChannel-Framework der deg\grqq ~
hervorgegangen ist, orientieren. Ziel dabei ist vor allem, die gleich
Funktionalitäten umzusetzen.\\
Die Logik konnte aufgrund dessen, dass beide Frameworks auf
Java aufsetzen komplett übernommen werden.\\
Da Vaadin alle Komponenten, die für die Umsetzung des
Prototypen notwendig waren, enthält, musste der Aufbau nicht
verändert werden, sondern nur einige Typen angepasst werden. Im Folgenden sind die
Vaadin-Komponenten aufgelistet die zur Umsetzung notwendig waren.\\
\begin{lstlisting}
Tree documentTree = new Tree();
VerticalLayout documentBox = new VerticalLayout();
HorizontalLayout statusbar = new HorizontalLayout();
HorizontalSplitPanel horizontalerSplit = new HorizontalSplitPanel();
GridLayout menuPane = new GridLayout(1,2);
BorderLayout borderLayout = new BorderLayout();
Table table = new Table();
\end{lstlisting}

Bei der Implementierung der Menüleiste, gab es keine weiteren Problem. Hier
bietet Vaadin ein entsprechend vorgefertigten \emph{MenueBar}-Typ an. Dieser
kann mit Elementengefüllt werden, wie es auch schon von JavaFX bekannt ist. Auch
die Verschachtelung von Untermenüs ist hier möglich.
%TODO Wirklich?
%TODO Listener???
\begin{lstlisting}
MenuBar menu = new MenuBar();
MenuBar.MenuItem bearbeitung = menu.addItem("Bearbeitung", null);
\end{lstlisting}

Für die Umsetzung geteilter Layout bietet Vaadin zwei Komponenten an, die je
nach Orientierung der Teilungsrichtung verwendet werden sollten. Dazugehört zum
einen das \emph{VerticalSplitPanel} - für die vertikale Teilung - und das
\emph{HorizontalSplitPanel} - für die horizontale Teilung.\\
Voraneinstellung für die Aufteilung der geteilten Bereiche, können durch die
Methode \emph{setSplitPosition(value, unit)} getroffen werden. Die \emph{unit}
bestimmt dabei, ob es sich um einen absoluten Wert handelt, oder einen
prozentualen.\\
Mit dieser Komponente ist es jedoch nur möglich einen Bereich in zwei weitere
Bereiche aufzuteilen. Diese können dann mittels \emph{setFirstComponent} und
\emph{setSecondComponent} befüllt werden.
\begin{lstlisting}
VerticalSplitPanel vertikalerSplit = new VerticalSplitPanel();

vertikalerSplit.setSplitPosition(30, Sizeable.Unit.PERCENTAGE);	
	
vertikalerSplit.setFirstComponent(Component);
vertikalerSplit.setSecondComponent(Component);
\end{lstlisting}

Tabellen sind weitaus komplexer strulturiert. Die Spalter werden bei Vaadin als
Container betrachtet. Das hat den Vorteil, dass je Spalte auch festgelegt werden
kann, welcher Datentyp dort angezeigt wird. Das geschieht mit der
Methode \emph{addContainerProperty(VALUE, TYPE, DEFAULT)}- Allgemein ist
somit gewährleistet, dass nur Typen angezeigt werde, die auch angezeigt werden sollen. Bezogen auf Objektorientierte Programmierung, ist diese Art der
Strukurierung vorteilhaft, da mit Objekten und nicht mit nativen Datentypen gearbeitet wird.
%TODO Quelle?
Im Prototypen wird dieser Vorteil jedoch nicht genutzt. Der Grund dafür ist,
dass für Zeichenketten und Zahlen keine spezifischen Typen implementiert wurden.
Die Klassen für die Strukturierung der Inhalte von Tabellen konnten übernommen
werden.\\
Will man Daten in die Tabelle einfügen, so hat man auf objektorientierten Ebene
viele Freiheiten, da die Methode \emph{addItem(Object[])} Werte vom Typ
%TODO Prüfen 
\emph{Object} erwartet. Um die Typisierung an dieser Stellen zu verbessern
müsste die Vaadin-\emph{Table} erweitert werden.
%TODO implementieren
\emph{Vaadin}
\begin{lstlisting}
Table table = new Table();
table.addContainerProperty("Vorgang", String.class, "");
table.addContainerProperty("Status", String.class, ""); 
table.addContainerProperty("Zuwendungs-\nsumme [EUR]", String.class, ""); 
table.addContainerProperty("Zahlungs-\nbetrag [EUR]", String.class, ""); 
table.addContainerProperty("Zahlungs-\ndatum", String.class, ""); 
		
initLines(table);
... 		
 		
private void initLines(Table table) {
	int i = 0;
	for(Document teilvorgang : teilvorgaenge){
		TeilvorgaeneTableData data = new TeilvorgaeneTableData(teilvorgang);
		table.addItem(new Object[]{ data.getVorgang(), data.getStatus(), 
		data.getZuwendungssumme(), data.getZahlungsbetrag(), data.getZahlungsdatum()}, i++);
	}
}
\end{lstlisting}
 
  Beim Befüllen des Verweise- und Inhaltsbaum traten ähnliche Probleme auf.
  Diese werden durch ein zweidimensionales Array abgebildet. Hinzu kommt noch,
  dass Elternelemente speziell gesetzt werden müssen. Bei JavaFX unterscheidet
  sich die Prozedur nicht sonderlich von anderen Codeabschnitten in denen einem
  Element ein anderes hinzugefügt wird. Das liegt vor allem an der
  Baumstruktur\footnote{Abbildung 3}, die sich durch JavaFX zieht.\\
 \emph{Vaadin}
 \begin{lstlisting}
 private void appendDocuments(Document doc, Tree tree) {
 	for (Document children : doc.getChildren()) {
 		tree.addItem(children.getTitel());
 		tree.setParent(children.getTitel(), getRootItem(tree));
 		tree.setChildrenAllowed(children.getTitel(), false);
 	}
 }
 \end{lstlisting}
 
 \emph{JavaFX}
 \begin{lstlisting}
 private void appendDocuments(Document doc, TreeItem treeItem) {
 	for (Document children : doc.getChildren()) {
 		TreeItem documentItem = new TreeItem();
 		documentItem.setValue(children.getTitel());
 		treeItem.getChildren().add(documentItem);
 	}
 }
 \end{lstlisting}
Das größte Problem bei der Umsetzung des Prototypen war die Toolbar. Das
Problem ist, dass dies keine Standardkomponente von Vaadin ist. Jedoch gibt es
ein Addon dafür. Die Dokumentation dafür ist allerdings veraltet. Daher war es
nicht möglich die Funktionsweise nachzuvollziehen und die Toolbar als
bestehende Komponente zu implementieren. Deshalb ist Implementation an dieser
Stelle etwas umfangreicher. Letztendlich schafft das die Möglichkeit eine
Toolbar-Klasse zu implementieren, die eine gleiche Syntax ausweist wie die aus
JavaFX.\\
\emph{Vaadin}
\begin{lstlisting}
		HorizontalLayout toolBar = new HorizontalLayout();

		String basepath = VaadinService.getCurrent().getBaseDirectory().getPath();
		FileResource imageDrop = new FileResource(new File(basepath+"/img/TbCopy.gif"));
		FileResource imagePrint = new FileResource(new File(basepath+"/img/TbPrint.gif"));
 		
		Button btDrop = new Button();
		btDrop.setIcon(imageDrop);

		Button btPrint = new Button();
		btPrint.setIcon(imagePrint);
		btPrint.setEnabled(false);
	 
		toolBar.addComponents(btDrop, btPrint, btLossOrg, btGetOrg, btHelp);	
\end{lstlisting}
  \emph{JavaFX}
 \begin{lstlisting}
		ToolBar toolbar = new ToolBar();
				
		Image imageDrop = new Image("ressources/TbCopy.gif");
		Image imagePrint = new Image("ressources/TbPrint.gif");
		
		Button btDrop = new Button(null, new ImageView(imageDrop));
		Button btPrint = new Button(null, new ImageView(imagePrint));
		btPrint.setDisable(true);
		
		toolbar.getItems().addAll(btDrop, new Separator(), btPrint);
 \end{lstlisting}
  Der Web-Client der deg hält die unterschiedlichen Fenster in Tabs. Dadurch
  musste bei diesem Prototyp eine Tab-Ansicht als übergreifendes GUI-Element
  implementiert werden. Dadurch verändern sich auch die Methoden zum öffnen
  neuer Mappen. Das einzige Problem welches dann noch bleibt ist, die
  Tab-Ansicht für jeden Tree-Controller zugänglich zu machen. Im Controller
  sind nämlich die Events zum öffnen einer neuen Mappe implementiert. Für den
  Prototypen wurde die Tab-Ansicht einfach statisch implementiert.
 \begin{lstlisting}
static TabSheet tabsheet = new TabSheet();
VertragsMappenView vertragsMappe = new VertragsMappenView(null); 
// Parameter ist die Bezeichnung der zu oeffnenden Mappe
// null = Standard-Mappe
tabsheet.addTab(vertragsMappe).setCaption(vertragsMappe.getTitle());
tabsheet.getTab(vertragsMappe).setClosable(true);
\end{lstlisting}
Bei den Klick-Events für die Bäume ist folgende Codezeile besonders wichtig.
\begin{lstlisting}
getVerweiseTree().setImmediate(true);
\end{lstlisting}
Das hat zur Folge, dass der Listener sofort auf den Klick reagiert. Ansonsten
wird das entsprechende Event später abgesetzt.
\begin{lstlisting}
getVerweiseTree().addValueChangeListener(new Property.ValueChangeListener() {
	@Override
	public void valueChange(Property.ValueChangeEvent event) {
		String selectedDocument =  getVerweiseTree().getValue().toString();
		ladeUndOeffneEntsprechendeMappe(selectedDocument);
	}
});           
\end{lstlisting}
Das Styling lässt sich bei Vaadin auch mittels Cascading-Style-Sheets umsetzen.
Somit ist es möglich dieselbe Datei zu verwenden, die auch bei JavaFX zum Einsatz
kommt. Die Einbindung der CSS-Datein erfolgt bei Vaadin jedoch auf einem
anderen Weg. Hier wird sie in folgendes Verzeichnis gelegt:
\emph{WebContent/VAADIN/themes/sampletheme/sample.css}. Im Code erfolgt die
Einbindung in der Hauptklasse wie folgt.\\
\emph{Vaadin}
\begin{lstlisting}
@Theme("sampletheme")
public class MyApplication extends UI {
\end{lstlisting}
\emph{JavaFX}
\begin{lstlisting}
String css = "layout.css";
ObservableList<String> cssStyle = loadSkin(css);

protected final ObservableList<String> loadSkin(String cssFileName) {
	ObservableList<String> cssStyle = FXCollections.observableArrayList();
	cssStyle.addAll(getClass().getResource(cssFileName).toExternalForm());
	return cssStyle;
}
\end{lstlisting}

Innerhalb der CSS-Datei ist es wichtig, dass ein Standard-Theme importiert
wird. Es sei denn das eigene Layout umfasst das komplette Styling und bedarf
somit keiner Standardeinstellung. Bei den Standards handelt es sich um zwei
unterschiedliche Layout, die wie folgt importiert werden.
\begin{lstlisting}
@import url("<../reindeer/styles.css"<)

@import url("<../runo/styles.css"<)
\end{lstlisting}

\subsection{Probleme der deg im Web}
Große Probleme in der deg bezüglich der GUI des Web-Clients bereitet die
Struktirierung. Im Desktop-Bereich wird dazu das GridBag-Layout genutzt. Die
Web-Frameworks stellen ein solchen Layout auch nicht mit ähnlichen Funktionen
bereit.\\
Aus diesem Grund wird in den Web-Client derzeit auf eine Strukturierung mittels
Tabellen zurückgegriffen. Bezüglich Wartbarkeit und Änderbarkeit ist dies
aufgrund der komplexen Struktur keine gute Lösung.\\

Eine Lösung für die Nutzung von Gridbag-Layouts mit Vaadin oder anderen
Web-Frameworks kann ich nicht geben. Eine kleiner Versuch zeigt aber, dass mit
Vaadin eine solches Layout schon mit weitaus weniger Komplexität umsetzbar
ist.\\

Probleme bereiten weiter hin die Zwischenabstände der Komponenten (Insets).
Diese müssten im Web über einen \emph{margin} realisiert werden, der bei Vaadin
nicht direkt gesetzt werden kann, sondern nur über CSS änderbar ist.

\subsection{Vergleich zu Wings}
Wings ist das Web-Framework welches momentan von der deg eingesetzt wird. Das
korrespondierende Framework für den Desktop-Client ist derzeit Swing.
Das größte Problem das sich bei dem Einsatz von Wings abzeichnet ist der
rückläufige Support. Die letzten Updates für Wings stammen aus dem Jahr 2008.
Seit dem wurde das Framework nicht weiterentwickelt. Das lässt ein baldiges
aussterben des Frameworks vermuten. \\
Die größte Gemeinsamkeit von Wings und Vaadin besteht darin, dass beide die
Kommunikation zwischen Serven und Client über AJAX abwickeln.\\
Die größten Unterschieden bestehen darin, das Vaadin eine weitaus größere
Community hat. Das liegt unter anderem auch daran, dass Vaadin auf dem GWT
aufsetzt. Weiterhin ist die Struktur von Vaadin nicht so stark an Swing
orientiert.\\
Weitere Unterschiede sind Abbildung 2 zu entnehmen:

Die Unterschiede zwischen den Frameworks in Bezug auf die obigen Schwerpunkte
sind nicht sehr groß. Das zeigt, dass Vaadin ebenfalls die nötigen Features mit
sich bringt, die zur Implementation eines Web-Channels für Profil C/S notwendig
sind.\\
Ein weiterer großer Unterschied ist in der Architektur zu finden. Diese
unterscheiden sich dahingehend, dass bei WingS\footnote{Abbildung 4} die
Kommunikation zwischen Client und Server ausschließlig über eine Java Servlet
API abgewickelt wird. Bei Vaadin\footnote{Abbildung 5} hingegen wird ebenfalls
das Servlet angesprochen. Weiterhin werden aber auch aus den Themes, die den
Style der GUI festlegen, bestimmte Daten geladen. Das fördert die Ersetzbarkeit
der einzelnen Komponenten innerhalb des Servers.


\section{Fazit - Ausblick auf den Multichannel}
Das Wings abgelöst werden muss steht aufgrund der Stagnation und des mangelnden
Supports fest. Das Vaadin-Framework eignet sich als Ersatz aufgrund der
entsprechenden Standardkomponenten sowie dem Support der an vielen Stellen in
Anspruch genommen werden kann. Zur Not kann man dieses auch von den Entwicklern
in Anspruch nehmen. Auch wenn das Vaadin-Framework vorgestellt wurde, gibt es
zahlreiche andere Web-Frameworks, die dafür in Frage kommen. Vor allem das GWT,
auf dem Vaadin aufsetzt ist ebenfalls ein Kandidat dafür. Dennoch sollte man
die Gemeinsamkeiten von Frameworks für die GUI im Web und die für den Desktop
in Bezug auf ein Multichannel-Framework nicht außer Acht lassen. Das Vaadin gut
dafür geeignet ist neben JavaFX als GUI-Framework eingesetzt zu  werden, sollte
verdeutlicht worden sein.\\
Das Multichannel-Framework wird benötigt, um den Arbeitsaufwand zum Erstellen
neuer User-Interfaces oder Client-seitigen Präsentationen möglichst gering zu
halten. Ziel ist es die GUIs nur ein einziges mal implementieren zu müssen und
die Kommunikation zwischen Server und Client möglichst allgemein zu halten. Das
Ganze wird auf der Basis eines Multichannel-Frameworks erreicht. Der
Multichannel steht somit architektonisch zwischen dem Server und den
unterschiedlichen Clients. Je mehr Gemeinsamkeiten die unterschiedlichen
Client-Frameworks dabei haben, desto einfacher ist das Multichannel-Framework.
Die Frameworks die innerhalb von diesem Praxisbericht und dem vorherigen
Praxisbericht evaluiert wurden, weisen viele Gemeinsamkeiten auf. Besondere
Aufmerksamkeit muss auf Tabellen gelegt werden. Dieser Bereich und der, welcher
zum Steuern der Events verantwortlich ist, werden den größten Teil des
Multichannel-Frameworks ausmachen.\\
Hierbei ist zu unterscheiden ob in der deg ein komplett neues
Multichannel-Framework eingeführt werden soll, oder das Bestehende erweitert
wird. Aufgrund dessen muss vorerst geprüft werden, ob eine Erweiterung in Bezug
auf bestimmte GUI-Frameworks überhaupt möglich ist.
 
\pagebreak
\bibliography{mybib}{}
$
Vaadin Lt: Book of Vaadin: Vaadin 7 Edition - 1st Revision \\
URL: https://vaadin.com/book \\
(27.09.2013)\\
\\
$

\section*{Abbildungen}


\begin{figure}[!htb]
			\begin{tabular}[c]{|l|}
			\hline\hline
			 \textbf{Vorteile} \\
				\hline\hline
				J2SE-API ist im vollen Umfang nutzbar \\
				\hline
				komplexe Anwendungen in Zusammenarbeit mit Servlets und
				Applikationsservern\\
				\hline
				Installation lokaler Software ist unnötig\\
				\hline
				In unterschiedlichen Browsern nutzbar \\
				\hline
				GUI muss nur einmal mithilfe eines Frameworks implementiert werden \\
				\hline
				Der Client muss (gezwungenermaßen) klein gehalten werden \\
				\hline
				\hline
				\textbf{Nachteile} \\
				\hline\hline
				Java-Plugin wird benötigt (Sicherheitsrisiko) \\
				\hline
				Java-Script muss aktiviert sein (Sicherheitsrisiko)\\
				\hline
				Abgleich der Java-Versionen notwendig\\
				\hline
				lange Initialisierung der JVM\\
				\hline
				Applet muss komplett heruntergeladen werden\\
				
			
\hline
\hline
			\end{tabular}
		\caption{Vor- und Nachteile von Java-Applets}
	\end{figure}	
	\begin{figure}[!htb]
			\begin{tabular}[c]{|l||ll|}
			\hline\hline
				\textbf{} & \textbf{WingS} 							&   \vline\textbf{Vaadin}\\
				\hline\hline
				\textbf{Container} & Servlet & \vline  { Servlet, Portlet}\\
				\hline
				\textbf{Stylability} &\multicolumn{2}{l|}{ Css, Layout-Templates}
				\tabularnewline\cline{2-3} & & \vline { Sass\footnote{Erweiterung von
				CSS3}}\\
				\hline
				\textbf{Komponenten} & \multicolumn{2}{l|}{unterschiedliche GUI-Elemente,
				eigene Komponenten}\\
				\hline
				\textbf{Render-Technik} & \multicolumn{2}{l|}{HTML, CSS, Java-Script} \\
				\hline
				
				\textbf{Verbreitung} &\multicolumn{2}{l|}{ großer Bekanntheitsgrad}
\tabularnewline 
& & \vline { v.a. durch das GWT}\\
\hline
\hline
			\end{tabular}
		\caption{Vergleich: WingS - Vaadin}
	\end{figure}
	\begin{figure}[!htb]
				\includegraphics[width=12cm]{JavaFX-Baum}
			\caption{JavaFX-Struktur}
		\end{figure}
	\begin{figure}[!htb]
				\includegraphics[width=12cm]{archwings}
			\caption{Wings-Architektur}
		\end{figure}
	\begin{figure}[!htb]
				\includegraphics[width=12cm]{architecture}
			\caption{Vaadin-Architektur}
		\end{figure}
\end{document}


