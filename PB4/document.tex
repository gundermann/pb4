\documentclass[a4paper]{scrartcl}
\usepackage[ngerman]{babel}
\addto\captionsngerman{\renewcommand{\refname}{}}
\usepackage[ansinew]{inputenc}
\usepackage{lmodern}
\usepackage[margin=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{listings} 
\usepackage{multirow}
\usepackage{cite}
\lstset{language=java} 
\lstset{basicstyle=\scriptsize}
\lstset{numbers=left, numberstyle=\tiny, numbersep=2pt} 
\graphicspath{{Bilder/}}

\linespread{1.5}

\title{Praxisbericht: Prototypische Implementierung eines JavaFX/Web-Channels zur Integration ins MulitChannel-Framework der deg}
\author{Niels Gundermann}

\begin{document}
\bibliographystyle{geralpha}
\large
\maketitle
\pagebreak
\tableofcontents
\pagebreak

\listoffigures
\pagebreak

\section{Einleitung}
Ausgehend von dem Fazit des Praxisberichtes \grqq Prototypische Implementierung
eines JavaFX-Channels zur Integration ins MulitChannel-Framework der deg\grqq
  ist Swing ein veraltetes Framework, dass durch ein neues Framework ersetzt
werden sollte. Dies bezieht sich nur auf den Bereich der Desktopanwedungen bzw.
dem Desktoprendering.\\
PROFIL-C/S wird nicht nur als Desktopanwendung verwendet, sondern auch im
Web-Bereich. Das bedeutet, dass bei einer Neuausrichtung der Technologien für
die unterschiedlichen Channels auch der Einsatz in Browsern bedacht werden
muss.\\
Derzeit setzt die deg dafür das Wings-Framework ein.
Dieses Framework ist allerdings genauso wie Swing veraltet und wird nicht mehr
gewartet. Support für dieses Framework wird demnach vergebens gesucht.\\
Aufgrund dessen wird in dieser Arbeit nach einer Alternative für den
WingS-Channel der deg und PROFIL C/S gesucht.\\ 
Da sich der vorherige Praxisbericht mit JavaFX beschäftigte, 
wird zu Beginn auf Möglichkeiten eingegangen, 
den implementierten Prototypen des JavaFX-Channel direkt im Browser zu
rendern.\\
Im Anschluss wird das Vaadin-Framework, als Beispiel für ein mögliches
Web-Framework, genauer beleuchtet. Dazu gehört auch ein Vergleich zum
bestehenden Wings-Framework.\\ 
Zum Ende wird ein Prototyp einer PROFIL-C/S
GUI für den Einsatz im Web vorgestellt und auf Probleme in Bezug auf das
Multichannel-Framework der deg eingegangen.
\section{JavaFX im Web?}
Ausgehend davon, dass es Ziel sein soll, einen Web-Channel für die deg zu
evaluieren und prototypisch zu implementieren, biete es sich an zu prüfen, ob
der schon bestehende Prototyp mit dem JavaFX-Framework ohne weiteres im Web
gerendert werden kann. Von einer ähnlichen Darstellung auf den unterschiedlichen
Oberflächen durch das gleiche Framework wird dabei ebenfalls ausgegangen.\\
JavaFX bietet die Möglichkeit sowohl auf dem Desktop, als auch in
einem Browser gerendert zu werden\cite{JavaFXDoc:Online}
Hierbei handelt es sich um ein Java-Applet. Das Deployment solcher Applets ist
jedoch vergleichsweise sehr zeitaufwändig. Der Grund dafür ist vor allem, dass
die JVM zuvor initialisiert werden muss.\cite{} Dem entgegenzuhalten ist, dass man
somit gezwungen ist, die Clients möglichst klein\footnote{bedeutet in diesem Kontext, dass sich die Funktionen, die
im Client implementiert sind, weites gehend nur auf die GUI und entsprechenden
Listener, die zum Steuern der Anwendung benötigt werden, beschränkt. Die Logik
und Funktionen, die über die Bedienung der GUI hinaus gehen, sollten sich nach
Möglichkeit auf dem Server befinden - unter der Voraussetzung, dass dort
genügend Speicher vorhanden ist, um die Anfragen der Clients in angemessener
Zeit beantworten zu können} zu halten. Allerdings sind Größe und Funktionalität
in einem bestehenden System schwer beeinflussbar. Weiterhin ist es auch
nicht das Ziel die Clients umzustricken.\\
Der große Vorteil dieser Technologie ist, dass für die GUI für beide
Oberflächen (Browser und Desktop) nur einmal entwickelt werden muss. Die Zusammenarbeit mit
Applikationsservern, was für Profil C/S unbedingt von Nöten ist, ist unter
Umständen möglich. Dafür müssen die Applets lediglich signiert werden. Das bedeutet, dass das Applet mit einem digitalen Zertifikat
unterzeichnet werden muss und somit gewährleistet wird, dass es sich dabei um
ein von der deg enntwickeltes Programm handelt. Somit kann der Nutzer eventuelle
Fehler und aufkommende Sicherheitslücken genau zuordnen.\cite{DeployTutJar}\\
Notwendig für die Nutzung von Java-Applets ist eine entsprechende html-Datei, in
der eine jnlp-Datei mittels Java-Script eingebunden wird. Weiterhin muss der Anwender mit einem
Browser arbeiten, in dem das Java-Plugin integriert oder installiert werden
kann. Zusätzlich ist die Aktivierung von Java-Script und damit das
Umgehen von Sicherheitsrichtlinien von Nöten.\cite{DeployTutApp}\\
Abbildung \ref{tab:applets} zeigt eine Tabelle in der Vor- und Nachteile dieser
Technologie aufgelistet sind.\\
\section{Web-Frameworks}
Web-Frameworks bieten die Möglichkeit bestimmte Inhalte mit Hilfe von
Technologien zu visualisieren, die vor allem in Internet-Browsern benutzt
werden. In der Regel ist das Ausführen von Programmen, die mit Web-Frameworks
implementiert wurden, auf dem Desktop nicht möglich. Wir ein solches Framework
zum Beispiel neben JavaFX eingesetzt, ist es Möglich die Logik zentral zu
implementieren und die Visualisierung zu separieren.\\
Der Nachteil, in Bezug auf die Implemetierung, ist, dass für unterschiedliche
Frameworks, die unterschiedliche Technologien nutzen, auch doppelter Aufwand
aufkommt. Um diese doppelten Aufwad möglichstklein zu halten, wurde dafür bei
der deg ein Multichannel implementiert.
\subsection{Multichannel}
Bezogen auf dieses Problem führt der Multichannel unterschiedlichen
Frameworks für die Visualisierung auf dem Desktop und im Browser
zusammen. Die Userinterfaces werden dann in der Syntax und Semantik des
Multichannel-Framework geschrieben. Die Entwickler müssen somit nicht die unterschiedlichen GUI-Frameworks kennen, sondern nur das
Multichannel-Framework. Je nachdem, auf welcher Plattform das Programm
ausgeführt wird, wird die GUI vom Multichannel über das entsprechende Framework
erstellt.\\
Um einen Multichannel implmentieren zu können, bedarf es einer gemeinsamen
Basis, der unterschiedlichen Frameworks. Die von den Frameworks genutzten
Technologien sind hierbei in erster Linie uninteressant. Das Ziel ist ein
allgemeines Framework zu schreiben, sodass nur noch unterschieden werden muss,
auf welcher Visualisierungsplattform man sich befindet.\\
Ausgegangen wird davon, dass als GUI-Framework für den Desktop JavaFX oder - wie
aktuell - Swing genutzt wird. Somit liegt es nahe ein Framework zu
betrachten das auf Java basiert, um die JVM als gemeinsame Basis nutzten zu
können. Aus diesen Grund wird im Folgenden das Vaadin-Framework vorgestellt.
\subsection{Vaadin}
Das Vaadin-Framework ist ein Open-Source Framework, das es erlaubt
Userinterfaces für Weboberflächen zu implementieren. Dies kann wie bei JavaFX
auf zwei Wegen geschehen. Zum einen durch Java-Code und zum Anderen durch einen Editor. 
Im weiteren Verlauf wird auf die erste Möglichkeit Bezug genommen.\\
Entwickelt wird Vaadin seit 2002. Damals zunächst als Adapter für ein anderes
Web-Framework. Ab 2006 wurde es als eigenes Produkt
entwickelt\footnote{text}.\\
Es enthält zum Einen einen großen Pool an UI-Komponenten, die dem Nutzer für
den Aufbau einer Web-GUI zur Verfügung stehen. Genauso wie bei andere
GUI-Frameworks, die auf Java basieren, ist es möglich neue und eigene
GUI-Komponenten zu entwickeln. Aus diesem Grund gibe es viele AddOns für
das Vaadin-Framework, die noch nicht in das Standardframework
integriert wurden.\\
Der Service bzw. die Unterstützung ist gegeben. Durch verständliche Tutorials,
der guten Dokumentation sowie entsprechenden Plugins für unterschiedliche
Entwicklungsumgebungen, findet man leicht einen Zugang zu dem Framework und kann
es ohne große Konfiguration einsetzen. Auch wenn in der offiziellen
Dokumentation \footnote{Book of Vaadin (siehe [Vaa13])} lediglich die
Standardkomponenten erklärt sind, gibt es zu jedem AddOn eine kurze Einweisung, sowie Beispiele und
Erklärungen. Auch die Community macht einen sehr aktiven Eindruck
\footnote{https://vaadin.com/forum}. Des weiteren stellen die Vaadin-Entwickler
ihr Know-How als externe Berater zur Verfügung.\\
Implementieren lassen sich die GUI-Komponenten nicht nur mittels Java-Code. Da
Vaadin auf der Client-Seite auf das Google-Web-Toolkit (GWT) aufbaut, 
können die UIs auch mittels anderer Sprachen, die zu der JVM kompatibel
sind\footnote{Bspw. Scala, Ruby, Groovy, Clojure, Python}, erstellt werden.
Weiterhin kann Vaadin auf allen Servern bereitgestellt werden, die einen 
Servlet- oder Portlet-Container enthalten. Beispiele dafür sind
Tomcat, Glasfish oder der in der deg eingesetzte JBoss.\\
Die Entwicklung findet auf dem Server statt. Für die Kommunikation zwischen
Server und Client wird AJAX verwendet\cite[S. 23ff.]{Vaadin}.
Von daher sind zusätzliche Plugins für Java-Anwendungen nicht nötig und somit
besteht auch das durch Plugins enstehende Sicherheitsrisiko nicht mehr.

\subsection{Anforderung an die Profil C/S - GUI} 
Sollte es zu einer Implementierung eines neuen Multichannel-Frameworks kommen,
müssen Techologien und Framework eingesetzt werden, die den Anforderung von
Profil C/S gerecht werden. Im Folgenden wird untersucht ob es möglich ist mit
dem Vaadin-Framework eine allgemeine GUI, wie sie in Profil C/S zur Anwendung
kommt, zu implemetieren. Dabei werde ich mich an der mit JavaFX-GUI, die aus dem orangegangen Praxisbericht - \grqq Prototypische Implementierung eines
JavaFX-Channels zur Integration ins MulitChannel-Framework der deg\grqq ~
hervorgegangen ist, orientieren. Ziel dabei ist vor allem, die gleich
Funktionalitäten umzusetzen.\\
Die Logik konnte aufgrund dessen, dass beide Frameworks auf
Java aufsetzen komplett übernommen werden.\\
Da Vaadin alle Komponenten, die für die Umsetzung des
Prototypen notwendig waren, enthält, musste der Aufbau nicht
verändert werden, sondern nur einige Typen angepasst werden. Im Folgenden sind die
Vaadin-Komponenten aufgelistet die zur Umsetzung notwendig waren.\\
\begin{lstlisting}
Tree documentTree = new Tree();
VerticalLayout documentBox = new VerticalLayout();
HorizontalLayout statusbar = new HorizontalLayout();
HorizontalSplitPanel horizontalerSplit = new HorizontalSplitPanel();
GridLayout menuPane = new GridLayout(1,2);
BorderLayout borderLayout = new BorderLayout();
Table table = new Table();
\end{lstlisting}
Bei der Implementierung der Menüleiste, gab es keine weiteren Problem. Hier
bietet Vaadin ein entsprechend vorgefertigten \emph{MenueBar}-Typ an. Dieser
kann mit Elementengefüllt werden, wie es auch schon von JavaFX bekannt ist. Auch
die Verschachtelung von Untermenüs und das Anfügen von Icon an die Menüpunkte
ist durch die Methode \emph{addItem(TEXT, ICON)} möglich.
\begin{lstlisting}
MenuBar menu = new MenuBar();
MenuBar.MenuItem schliessen = menu.addItem("Schließen", null);
\end{lstlisting}
Um Aktionen an diesem Menü ausführen zu können muss auch bei Vaadin ein
ensprechendet Listener implementiert. Dies geschieht über die Methode
\emph{setCommand(COMMAND)}. Diese Listener-Interfaces gleichen von der
Implementierung her den Action-Listener, aus dem Swing- oder
JavaFX-Framework.
\begin{lstlisting}
schliessen.setCommand(new Command() {
	@Override
	public void menuSelected(MenuItem selectedItem) {
		close();
	}
});
\end{lstlisting}
Für die Umsetzung geteilter Layout bietet Vaadin zwei Komponenten an, die je
nach Orientierung der Teilungsrichtung verwendet werden sollten. Dazugehört zum einen das \emph{VerticalSplitPanel} - für die vertikale Teilung - und das \emph{HorizontalSplitPanel} - für die horizontale Teilung.\\
Voraneinstellung für die Aufteilung der geteilten Bereiche, können durch die
Methode \emph{setSplitPosition(VALUE, UNIT)} getroffen werden. Die \emph{UNIT}
bestimmt dabei, ob es sich um einen absoluten Wert handelt, oder einen
prozentualen.\\
Mit dieser Komponente ist es jedoch nur möglich einen Bereich in zwei weitere
Bereiche aufzuteilen. Diese können dann mittels
\emph{setFirstComponent(COMPONENT)} und \emph{setSecondComponent(COMPONENT)}
befüllt werden.
\begin{lstlisting}
VerticalSplitPanel vertikalerSplit = new VerticalSplitPanel();

vertikalerSplit.setSplitPosition(30, Sizeable.Unit.PERCENTAGE);	
	
vertikalerSplit.setFirstComponent(Component);
vertikalerSplit.setSecondComponent(Component);
\end{lstlisting}
Tabellen sind weitaus komplexer strulturiert. Die Spalter werden bei Vaadin als
Container betrachtet. Das hat den Vorteil, dass je Spalte auch festgelegt werden
kann, welcher Datentyp dort angezeigt wird. Das geschieht mit der
Methode \emph{addContainerProperty(TEXT, TYPE, DEFAULT)}. Allgemein
ist somit gewährleistet, dass nur Typen angezeigt werde, die auch angezeigt werden sollen. 
Bezogen auf Objektorientierte Programmierung, ist diese Art der
Strukurierung vorteilhaft, da mit Objekten und nicht mit nativen Datentypen gearbeitet wird.
Im Prototypen wird dieser Vorteil jedoch nicht genutzt. Der Grund dafür ist,
dass für Zeichenketten und Zahlen keine spezifischen Typen implementiert wurden.
\begin{lstlisting}
Table table = new Table();
table.addContainerProperty("Vorgang", String.class, "");
table.addContainerProperty("Status", String.class, ""); 
table.addContainerProperty("Zuwendungs-\nsumme [EUR]", String.class, ""); 
table.addContainerProperty("Zahlungs-\nbetrag [EUR]", String.class, ""); 
table.addContainerProperty("Zahlungs-\ndatum", String.class, ""); 
		
initLines(table);
... 		
 		
private void initLines(Table table) {
	int i = 0;
	for(Document teilvorgang : teilvorgaenge){
		TeilvorgaeneTableData data = new TeilvorgaeneTableData(teilvorgang);
		table.addItem(new Object[]{ data.getVorgang(), data.getStatus(), 
		data.getZuwendungssumme(), data.getZahlungsbetrag(), data.getZahlungsdatum()}, i++);
	}
}
\end{lstlisting}
Will man Daten in die Tabelle einfügen, so hat man auf objektorientierten Ebene
viele Freiheiten, da die Methode \emph{addItem(OBJECT[])} ein Array mit Werten
vom Typ \emph{Object} erwartet. Ist der Typ jedoch durch
\emph{addContainerProperty(TEXT, TYPE, DEFAULT)} festgelegt, wird für den
Fall, dass ein falscher Typ in die Tabelle geschrieben werden soll, der
Standardwert eingetragen. Die in der Klasse \emph{TableTest} im Anhang ist ein
solcher Fall implementiert\ref{pic:testtable}.
Bezüglich der Typsicherheit müssen hier noch Erweiterungen vorgenommen
werden. Bei Angabe eines falschen Types sollte nicht einfach der Standardwert
zurückgegeben werden. Vielmehr sollte hier darauf hingewiesen werden, dass der Falsche Typ verwendet wurde.
Dies könnte durch eine generische Erweiterung der Vaadin-\emph{Table}
und einem Container, der die zu visualisierenden Daten des
Businessobjekt enthält, realisiert werden. Durch den Container wird dann
abgesichert, dass die Tabelle keine inkompatible Typen enthält.\\
Im Prototypen wird geschieht dies in der Klasse /emph{CommonTable}. Hier
fungiert die Methode /emph{getAllValues()} als ein solcher Container, der die
Werte und die dazugehörigen Typen mitliefert. Da die Klassen, die von
/emph{CommonTable} erben, generisch auf das entsprechende Datenobjekt abgestimmt
sind, kann es nicht mehr zu inkompatiblen Typen kommen.\\
Beim Befüllen des Verweise- und Inhaltsbaum traten keine weiteren Probleme
auf. Hierbei handelt es sich um eine einfache Eltern-Kind-Beziehung. Jedoch
muss neben dem hinzufügen zum Baum, auch das Elterelement explizit gesetzt
werden. Dieses Problem kann allerdings durch Auslagerung in eine
allgemeine Methode vereinfacht werden
\begin{lstlisting}
private void appendDocuments(Document doc, Tree tree) {
	for (Document children : doc.getUnterDokumente()) {
		tree.addItem(children.getTitel());
		tree.setParent(children.getTitel(), getRootItem(tree));
		tree.setChildrenAllowed(children.getTitel(), false);
	}
}
\end{lstlisting}
Bei den Klick-Events für die Bäume ist folgende Codezeile besonders wichtig.
\begin{lstlisting}
getVerweiseTree().setImmediate(true);
\end{lstlisting}
Das hat zur Folge, dass der Listener sofort auf den Klick reagiert. Ansonsten
wird das entsprechende Event später abgesetzt.
Das größte Problem bei der Umsetzung des Prototypen war die Toolbar. Hierfür
gibt es keine Standardkomponente, wie man es von anderen UI-Framework gewohnt
ist. Es gibt zwar zwei Toolbar-Add-Ons, die in das Projekt eingebunden werden
können\cite{AOTool,AOToolWin}. Diese werden jedoch ab Vaadin 7 nicht mehr unterstützt.\\
Aufgrund dessen musste ich für den Prototypen eine eigene Toolbar
implementieren. Den Aufbau habe ich dabei so einfach wie möglich gehalten. Die
Toolbar ist ein Layout-Container in den mehrere Buttons eingefügt werden.\\
\begin{lstlisting}
HorizontalLayout toolBar = new HorizontalLayout();
String basepath = VaadinService.getCurrent().getBaseDirectory().getPath();
FileResource imageDrop = new FileResource(new File(basepath+"/img/TbCopy.gif"));
FileResource imagePrint = new FileResource(new File(basepath+"/img/TbPrint.gif"));
 		
Button btDrop = new Button();
btDrop.setIcon(imageDrop);

Button btPrint = new Button();
btPrint.setIcon(imagePrint);
btPrint.setEnabled(false);
	 
toolBar.addComponents(btDrop, btPrint, btLossOrg, btGetOrg, btHelp);	
\end{lstlisting}
Der Web-Client der deg hält die unterschiedlichen Fenster in Tabs. Dadurch
musste bei diesem Prototyp eine Tab-Ansicht als übergreifendes GUI-Element
implementiert werden. Dadurch verändern sich auch die Methoden zum öffnen
neuer Mappen. Das einzige Problem welches dann noch bleibt ist, die
Tab-Ansicht für jeden Tree-Controller zugänglich zu machen. Im
Controller sind nämlich die Events zum öffnen einer neuen Mappe implementiert. Für den
Prototypen wurde die Tab-Ansicht einfach statisch implementiert.
\begin{lstlisting}
static TabSheet tabsheet = new TabSheet();
VertragsMappenView vertragsMappe = new VertragsMappenView(null); 
// Parameter ist die Bezeichnung der zu oeffnenden Mappe
// null = Standard-Mappe
tabsheet.addTab(vertragsMappe).setCaption(vertragsMappe.getTitle());
tabsheet.getTab(vertragsMappe).setClosable(true);
\end{lstlisting}
Das Styling lässt sich bei Vaadin mittels auch Cascading-Style-Sheets umsetzen.
Somit ist es möglich dieselbe Datei zu verwenden, die auch bei dem
JavaFX-Prototyen zum Einsatz kommt. Die Einbindung der CSS-Datei erfolgt bei
Vaadin jedoch auf einem anderen Weg. Hier wird sie in folgendes Verzeichnis gelegt:
\emph{WebContent/VAADIN/themes/sampletheme/sample.css}. Im Code erfolgt die
Einbindung in der Hauptklasse durch eine Annotation.\\
\begin{lstlisting}
@Theme("sampletheme")
public class MyApplication extends UI {
\end{lstlisting}
Innerhalb der CSS-Datei ist es wichtig, dass ein Standard-Theme importiert
wird. Es sei denn das eigene Layout umfasst das komplette Styling und bedarf
somit keiner Standardeinstellung. Für Prototypen empfand ich es jedoch zu
aufwendig, ein komplettes Theme zu entwerfen und habe mich für den Import
eines Standard-Theme entschieden. Bei den Standards handelt es sich um
zwei unterschiedliche Layout, die wie folgt importiert werden.
\begin{lstlisting}
@import url("<../reindeer/styles.css"<)
//oder
@import url("<../runo/styles.css"<)
\end{lstlisting}
\subsection{Probleme der deg im Web}
Große Probleme in der deg bezüglich der GUI des Web-Clients bereitet die
Strukturierung. Im Desktop-Bereich wird dazu das GridBag-Layout genutzt. Die
Web-Frameworks stellen ein solches Layout nicht bereit.\\
Aus diesem Grund wird in den Web-Client derzeit auf eine Strukturierung mittels
Tabellen-Layouts zurückgegriffen\cite{CodeGBL, CodeGBLCG}. Nach den
Kommentaren im Code orientiert sich das Wings-Gridba-Layout an das
Swing-Gridbag-Layout. Allerdings wird dabei nur erreicht ein
Swing-Gridbag-Layout so ähnlich wie möglich nachzubauen. Das zeigt schon, dass
das hier verwendetet Framework keine optimale Lösung ist, da das
Gridbag-Layout ein zentraler Bestandteil der Profil C/S-GUI ist.\\
Eine Lösung für die Nutzung von Gridbag-Layouts mit Vaadin oder anderen
Web-Frameworks kann ich nicht geben. Eine kleiner Versuch
zeigt aber, dass mit Vaadin eine solches Layout schon mit weitaus weniger Komplexität umsetzbar
ist. Dabei erweitert die Klasse \emph{GridBagLayout} das Vaadin GridLayout.
Die Strukturierung des GridLayouts von Vaadin ist in die allgemeine
Layoutstruktur von Vaadin intergriet\cite{CodeGL} und ist deshalb besser für
eine strukturierte und einheitliche GUI geeignet, als eine Lösung, die aus der
herkömmlichen Layout-Struktur herausfällt, wie es bei Wings der Fall ist.\\
%%TODO Code
Probleme bereiten weiter hin die Zwischenabstände der Komponenten (Insets).
Diese müssten im Web über einen \emph{margin} realisiert werden, der bei Vaadin
nicht direkt gesetzt werden kann, sondern nur über CSS änderbar ist.
\subsection{Vergleich zu Wings}
Wings ist das Web-Framework welches momentan von der deg eingesetzt wird. Das
korrespondierende Framework für den Desktop-Client ist derzeit Swing\cite{WingsAllg}.
Das größte Problem das sich bei dem Einsatz von Wings abzeichnet ist der
rückläufige Support. Die letzten Updates für Wings stammen aus dem Jahr 2008.
Seit dem wurde das Framework nicht weiterentwickelt. Das lässt ein baldiges
aussterben vermuten.\\
Die größte Gemeinsamkeit von Wings und Vaadin besteht darin, dass beide die
Kommunikation zwischen Serven und Client über AJAX
abwickeln.\cite[S 23.]{Vaadin}\cite{WingsAllg}\\
Die größten Unterschieden bestehen darin, das Vaadin eine weitaus größere
Community hat. Das liegt unter anderem auch daran, dass Vaadin auf dem GWT
aufsetzt. Weiterhin ist die Struktur von Vaadin nicht so stark an Swing
orientiert.\\
Weitere Gemeinsamkeiten und Unterschiede sind Abbildung \ref{tab:wingsvsvaadin}
zu entnehmen.
Die Unterschiede zwischen den Frameworks in Bezug auf die Schwerpunkte bezüglich
Profil C/S-GUIs sind nicht sehr groß. Das zeigt, dass Vaadin ebenfalls die
nötigen Features mit sich bringt, die zur Implementation eines Web-Channels für Profil C/S notwendig
sind.\\
Ein weiterer großer Unterschied ist in der Architektur zu finden. Diese
unterscheiden sich dahingehend, dass bei WingS\ref{pic:wingsarch} die
Kommunikation zwischen Client und Server ausschließlig über eine Java Servlet
API abgewickelt wird. Vaadin\ref{pic:vaadinarch} hingegen kann diese
Kommunikation auch über einen Portlet-Container
abwickeln\cite[53-56]{Vaadin }\cite{wingsArt}.
\section{Fazit}
Das Wings abgelöst werden muss, steht aufgrund der Stagnation und des mangelnden
Supports fest. Das Vaadin-Framework eignet sich als Ersatz, aufgrund der
entsprechenden Standardkomponenten, sowie dem Support der an vielen Stellen in
Anspruch genommen werden kann. Zur Not kann man auch Unterstützung von den
Entwicklern von Vaadin in Anspruch nehmen. Auch wenn ich hier das Vaadin-Framework
vorgestellt wurde, gibt es zahlreiche andere Web-Frameworks, die dafür in Frage kommen. 
Vor allem das GWT, auf dem Vaadin aufsetzt ist ebenfalls ein Kandidat dafür.\\
Da mit Abschluss dieses Praxisberichtes jeweils eine neues Framework für den
Desktop- und den Web-Client für Profil C/S evaluiert wurde, muss festgelegt
werden welche Frameworks für die neuen Channels eingesetzt werden sollen. Erst
dann kann eine konkrete Umsetzung dieser erfolgen.\\
Dabei werden sich die Entwickler an den bestehenden Channels für Swing und wingS
orientieren müssen. Eine Umstrukturiereung des Multichannels ist meiner Meinung nach 
keine Option, da die Ressourcen in deg derzeit für solche Umsetzungen zu knapp
sind.\\
Jedoch könnte man dabei ein einheitliches \emph{Look and Feel} umsetzen, da mit 
JavaFX auch der Desktop-Client mittels Css gestaltet werden kann.
\pagebreak
\section*{Anhänge}
\appendix
\section{Literaturverzeichnis}
\bibliography{mybib}{}
\section{Abbildungen}
\begin{figure}[!htb]
			\begin{tabular}[c]{|l|}
			\hline\hline
			 \textbf{Vorteile} \\
				\hline\hline
				J2SE-API ist im vollen Umfang nutzbar \\
				\hline
				komplexe Anwendungen in Zusammenarbeit mit Servlets und
				Applikationsservern\\
				\hline
				Installation lokaler Software ist unnötig\\
				\hline
				In unterschiedlichen Browsern nutzbar \\
				\hline
				GUI muss nur einmal mithilfe eines Frameworks implementiert werden \\
				\hline
				Der Client muss (gezwungenermaßen) klein gehalten werden \\
				\hline
				\hline
				\textbf{Nachteile} \\
				\hline\hline
				Java-Plugin wird benötigt (Sicherheitsrisiko) \\
				\hline
				Java-Script muss aktiviert sein (Sicherheitsrisiko)\\
				\hline
				Abgleich der Java-Versionen notwendig\\
				\hline
				lange Initialisierung der JVM\\
				\hline
				Applet muss komplett heruntergeladen werden\\
\hline
\hline
			\end{tabular}
		\caption{Vor- und Nachteile von Java-Applets}
		\label{tab:applets}
	\end{figure}	
	\begin{figure}[!htb]
			\begin{tabular}[c]{|l||ll|}
			\hline\hline
				\textbf{} & \textbf{WingS} 							&   \vline\textbf{Vaadin}\\
				\hline\hline
				\textbf{Container} & Servlet & \vline  { Servlet, Portlet}\\
				\hline
				\textbf{Stylability} &\multicolumn{2}{l|}{ Css, Layout-Templates}
				\tabularnewline\cline{2-3} & & \vline { Sass\footnote{Erweiterung von
				CSS3}}\\
				\hline
				\textbf{Komponenten} & \multicolumn{2}{l|}{unterschiedliche GUI-Elemente,
				eigene Komponenten}\\
				\hline
				\textbf{Render-Technik} & \multicolumn{2}{l|}{HTML, CSS, Java-Script} \\
				\hline
				
				\textbf{Verbreitung} &\multicolumn{2}{l|}{ großer Bekanntheitsgrad}
\tabularnewline 
& & \vline { v.a. durch das GWT}\\
\hline
\hline
			\end{tabular}
		\caption{Vergleich: WingS - Vaadin}
		\label{tab:wingsvsvaadin}
	\end{figure}
	 
	%Bilder
	\begin{figure}[!htb]
				\includegraphics[width=12cm]{TestTable}
			\caption{TestTable-GUI}
			\label{pic:testtable}
		\end{figure}
	\begin{figure}[!htb]
				\includegraphics[width=12cm]{archwings}
			\caption{Wings-Architektur}
			\label{pic:wingsarch}
		\end{figure}
	\begin{figure}[!htb]
				\includegraphics[width=12cm]{architecture}
			\caption{Vaadin-Architektur}
			\label{pic:vaadinarch}
		\end{figure}
\end{document}


